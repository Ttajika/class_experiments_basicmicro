
# app.py
import streamlit as st
import pandas as pd
import sqlite3
import os
import random
import matplotlib.pyplot as plt
import time

# --- „Éö„Éº„Ç∏Ë®≠ÂÆö ---
st.set_page_config(page_title="Â∏ÇÂ†¥ÂÆüÈ®ì", layout="centered")
DB_PATH = "market.db"

# --- DBÊé•Á∂ö ---
def connect():
    return sqlite3.connect(DB_PATH)

def initialize_db():
    conn = connect()
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS players (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            money INTEGER,
            endowment INTEGER,
            bid INTEGER,
            qty INTEGER,
            choice INTEGER,
            payoff INTEGER,
            submitted INTEGER DEFAULT 0,
            info INTEGER,
            unit INTEGER,
            class_name TEXT
        )
    """)
    c.execute("""
        CREATE TABLE IF NOT EXISTS group_info (
            id INTEGER PRIMARY KEY,
            value INTEGER,
            final_price INTEGER,
            round INTEGER,
            confirmed INTEGER DEFAULT 0,
            show_result INTEGER DEFAULT 0,
            show_graph INTEGER DEFAULT 0
        )
    """)
    c.execute("""
        CREATE TABLE IF NOT EXISTS player_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            round INTEGER,
            choice INTEGER,
            bid INTEGER,
            qty INTEGER,
            unit INTEGER,
            money INTEGER,
            endowment INTEGER,
            payoff INTEGER,
            info INTEGER,
            class_name TEXT
        )
    """)
    c.execute("INSERT OR IGNORE INTO group_info (id, value, round) VALUES (1, 100, 1)")
    conn.commit()
    conn.close()

def load_player(student_id):
    conn = connect()
    c = conn.cursor()
    result = c.execute("SELECT * FROM players WHERE name = ?", (student_id,)).fetchone()
    conn.close()
    if result:
        keys = ["id", "name", "money", "endowment", "bid", "qty", "choice", "payoff", "submitted", "info", "unit"]
        return dict(zip(keys, result))
    return None

def save_player(player):
    conn = connect()
    c = conn.cursor()
    c.execute("""
        UPDATE players SET bid=?, qty=?, choice=?, submitted=1
        WHERE name=?
    """, (player['bid'], player['qty'], player['choice'], player['name']))
    conn.commit()
    conn.close()

def initialize_player(student_id, class_name):
    conn = connect()
    c = conn.cursor()
    value = c.execute("SELECT value FROM group_info WHERE id=1").fetchone()
    if not value:
        value = 100
    else:
        value = value[0]/100
    endowment = random.choices([1, 2, 3, 4], weights=[value**3, value**2, value, 1])[0]
    money = 485 - 111 * endowment
    info = int(random.expovariate(1 / value))
    c.execute("""
        INSERT INTO players (name, money, endowment, submitted, info, class_name)
        VALUES (?, ?, ?, 0, ?, ?)
    """, (student_id, money, endowment, info, class_name))
    conn.commit()
    conn.close()
    return {"name": student_id, "money": money, "endowment": endowment, "submitted": False, "info": info}


def load_group_value():
    conn = connect()
    c = conn.cursor()
    result = c.execute("SELECT value FROM group_info WHERE id=1").fetchone()
    conn.close()
    return result[0] if result else 100

def load_round():
    conn = connect()
    c = conn.cursor()
    result = c.execute("SELECT round FROM group_info WHERE id=1").fetchone()
    conn.close()
    return result[0] if result else 1

def load_confirmation():
    conn = connect()
    c = conn.cursor()
    result = c.execute("SELECT confirmed FROM group_info WHERE id=1").fetchone()
    conn.close()
    return result[0] if result else 0

def confirm_results():
    conn = connect()
    c = conn.cursor()
    c.execute("UPDATE group_info SET confirmed = 1 WHERE id=1")
    conn.commit()
    conn.close()

def reset_experiment():
    new_value = random.randint(80, 200)
    conn = connect()
    c = conn.cursor()
    c.execute("DELETE FROM players")
    c.execute("UPDATE group_info SET final_price=NULL, round=1, value=?, confirmed=0, show_graph=0", (new_value,))
    conn.commit()
    conn.close()

def next_round():
    conn = connect()
    c = conn.cursor()
    c.execute("UPDATE group_info SET round = round + 1, final_price = NULL, confirmed = 0, show_graph = 0")
    c.execute("UPDATE players SET submitted=0, bid=NULL, qty=NULL, choice=NULL")
    conn.commit()
    conn.close()

def set_payoffs(players, value, class_name, round_num):
    price = -1
    demand, supply = 1000, 0

    while supply < demand and price < 300:
        price += 1
        demand, supply = 0, 0
        for p in players:
            if p["choice"] == 1 and p["bid"] >= price:
                demand += p["qty"]
            elif p["choice"] == -1 and p["bid"] <= price:
                supply += p["qty"]

    conn = connect()
    c = conn.cursor()
    for p in players:
        unit = 0
        if p["choice"] == 1 and p["bid"] >= price:
            unit = p["qty"]
        elif p["choice"] == -1 and p["bid"] <= price:
            unit = -p["qty"]
        money = p["money"] - price * unit
        endowment = p["endowment"] + unit
        payoff = int(value * endowment + money)


        c.execute("""UPDATE players SET payoff=?, money=?, endowment=?, unit=? WHERE id=?""",
          (payoff, money, endowment, unit, p["id"]))
        c.execute("""
            INSERT INTO player_history (name, round, choice, bid, qty, unit, money, endowment, payoff, info, class_name)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (p["name"], round_num, p["choice"], p["bid"], p["qty"], unit, money, endowment, payoff, p["info"], class_name))


    c.execute("UPDATE group_info SET final_price=?, show_graph=1 WHERE id=1", (price,))
    conn.commit()
    conn.close()
    return price

def load_final_price():
    conn = connect()
    c = conn.cursor()
    result = c.execute("SELECT final_price FROM group_info WHERE id=1").fetchone()
    conn.close()
    return result[0] if result else None

def load_all_players():
    conn = connect()
    c = conn.cursor()
    results = c.execute("SELECT * FROM players").fetchall()
    keys = ["id", "name", "money", "endowment", "bid", "qty", "choice", "payoff", "submitted", "info", "unit"]
    conn.close()
    return [dict(zip(keys, row)) for row in results]

def compute_inverse_demand_supply(players):
    price_range = list(range(0, 201))
    demand, supply = [], []
    for p in price_range:
        d = sum(pl["qty"] for pl in players if pl["choice"] == 1 and pl["bid"] >= p)
        s = sum(pl["qty"] for pl in players if pl["choice"] == -1 and pl["bid"] <= p)
        demand.append(d)
        supply.append(s)
    return price_range, demand, supply



# --- „Éó„É¨„Ç§„É§„ÉºÁîªÈù¢ ---
def show_player_ui(class_name):
    if "student_id" not in st.session_state:
        st.session_state.student_id = ""

    st.subheader("„É≠„Ç∞„Ç§„É≥")

    student_id = st.text_input("Â≠¶Á±çÁï™Âè∑„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ", value=st.session_state.student_id)
    if student_id:
        st.session_state.student_id = student_id


    if student_id:
        player = load_player(student_id)
        if not player:
            player = initialize_player(student_id, class_name)
            st.success(f"Êñ∞„Åó„Åè„Éó„É¨„Ç§„É§„Éº {student_id} „ÇíÁôªÈå≤„Åó„Åæ„Åó„Åü")
            time.sleep(2)
            st.rerun()
        else:
            st.info(f"„Çà„ÅÜ„Åì„Åù„ÄÅ{student_id} „Åï„Çì")

        # ÂøÖË¶Å„Å™ÊÉÖÂ†±ÂèñÂæó
        try:
            round_num = load_round()
        except:
            round_num = 1

        try:
            group_value = load_group_value()
        except:
            group_value = 100

        confirmed = load_confirmation()
        st.markdown(f"**„É©„Ç¶„É≥„Éâ {round_num}ÔΩúÊâÄÊåÅÈáë:** {player['money']} ÂÜÜ„ÄÄÔΩú„ÄÄ**ÂïÜÂìÅ:** {player['endowment']} ÂÄã")
        st.markdown(f"üß† „ÅÇ„Å™„Åü„Å´‰∏é„Åà„Çâ„Çå„ÅüÊÉÖÂ†±ÔºàinfoÔºâ: **{player['info']}**")

        # Êú™ÊèêÂá∫„Åß„ÇÇchoice„ÅåNone„ÅÆ„Åæ„Åæ„Å´„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜË£úÊ≠£ÔºàÊ¨°„ÅÆ„É©„Ç¶„É≥„ÉâÈñãÂßãÊôÇÔºâ
        # ‚Äª„Éï„Ç©„Éº„É†„Å´ÂÖ•„ÇãÂâç„Å´Ë°®Á§∫„Åï„Çå„Å™„ÅÑ„Çà„ÅÜ„ÄÅÊèêÂá∫Ê∏à„ÅøÊâ±„ÅÑ„ÅØ„Åó„Å™„ÅÑ
        if not confirmed and (player.get("choice") is None or player.get("bid") is None or player.get("qty") is None):
            player["choice"] = 0
            player["bid"] = 0
            player["qty"] = 0
            save_player(player)

        # „É™„É≠„Éº„Éâ„Éú„Çø„É≥
        if st.button("üîÑ Â∏ÇÂ†¥ÁµêÊûú„ÇíÂÜçË™≠„ÅøËæº„Åø„Åô„Çã"):
                st.rerun()

        if player.get("payoff") is not None:
                
                
                # ÈÄÜÈúÄË¶Å„Éª‰æõÁµ¶Èñ¢Êï∞„Ç∞„É©„ÉïÊèèÁîª
                conn = connect()
                c = conn.cursor()
                show_graph = c.execute("SELECT show_graph FROM group_info WHERE id=1").fetchone()
                if show_graph[0] == 1:
                    st.subheader("Â∏ÇÂ†¥ÁµêÊûú")
                    final_price = load_final_price()
                    st.markdown(f"ü™ô Â∏ÇÂ†¥‰æ°Ê†º: **{final_price} ÂÜÜ**")
                    if player.get("unit") > 0:
                        st.markdown(f"üõí Ë≥ºÂÖ•Êï∞Èáè: {player['unit']} ÂÄã")
                    elif player.get("unit") < 0:
                        st.markdown(f"üì§ Â£≤Âç¥Êï∞Èáè: {abs(player['unit'])} ÂÄã")
                    elif player.get("unit") == 0:
                        st.markdown("‚ö†Ô∏è„Åì„ÅÆ„É©„Ç¶„É≥„Éâ„Åß„ÅØÂèñÂºï„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ")
                    if player.get("choice") == 0:
                        st.markdown("‚ö†Ô∏è „Åì„ÅÆ„É©„Ç¶„É≥„Éâ„Åß„ÅØÂèñÂºï„Å´ÂèÇÂä†„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ")
                    players = load_all_players()
                    price_range = list(range(0, 201))
                    prices, demand, supply = compute_inverse_demand_supply(players)

                    fig, ax = plt.subplots()
                    ax.plot(demand, prices, label="D")
                    ax.plot(supply, prices, label="S")
                    ax.set_xlabel("Q")
                    ax.set_ylabel("P")
                    ax.set_title("Market Demmand and Supply")
                    ax.legend()
                    st.pyplot(fig)

                    if confirmed:
                        st.subheader("ÁµêÊûúÔºàÂ†±ÈÖ¨Á¢∫ÂÆöÂæåÔºâ")
                        st.markdown(f"üí∞ **Â†±ÈÖ¨:** {player['payoff']} ÂÜÜ")
                        st.markdown(f"üì¶ ÊúÄÁµÇÊâÄÊåÅ: {player['endowment']} ÂÄã | üíµ {player['money']} ÂÜÜ")
                    else:
                        st.info("ÁÆ°ÁêÜËÄÖ„ÅåÁµêÊûú„ÇíÁ¢∫ÂÆö„Åô„Çã„Åæ„Åß„ÄÅÂ†±ÈÖ¨„ÅØË°®Á§∫„Åï„Çå„Åæ„Åõ„Çì„ÄÇ")
        conn = connect()
        c = conn.cursor()
        show_graph = c.execute("SELECT show_graph FROM group_info WHERE id=1").fetchone()
        if show_graph[0]==0:
            st.subheader("ÂèñÂºï„ÅÆÂÖ•Âäõ")
            if not confirmed:
                with st.form("trade_form"):
                    choice = st.radio("ÂèñÂºïÈÅ∏Êäû", [1, -1], format_func=lambda x: "Ë≥ºÂÖ•" if x == 1 else "Â£≤Âç¥")
                    bid = st.slider("Â∏åÊúõ‰æ°Ê†ºÔºàÂÜÜÔºâ", min_value=0, max_value=200, step=1)
                    qty = st.slider("Â∏åÊúõÊï∞ÈáèÔºàÂÄãÔºâ", min_value=1, max_value=5, step=1)
                    submitted = st.form_submit_button("ÊèêÂá∫")

                    if submitted:
                        if choice == 1 and bid * qty > player['money']:
                            st.warning("ÊâÄÊåÅÈáë„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ")
                        elif choice == -1 and qty > player['endowment']:
                            st.warning("Â£≤Âç¥Êï∞Èáè„ÅåÂ§ö„Åô„Åé„Åæ„Åô„ÄÇ")
                        else:
                            player.update({
                                "choice": choice,
                                "bid": bid,
                                "qty": qty,
                                "submitted": True
                            })
                            save_player(player)
                            st.success("ÊèêÂá∫„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇÁµêÊûú„ÅåÂá∫„Çã„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ")


# --- ÁÆ°ÁêÜËÄÖÁîªÈù¢ ---
def show_admin_ui(class_name):
    st.header("üîê ÁÆ°ÁêÜËÄÖ„É¢„Éº„Éâ")
    group_value = load_group_value()
    round_num = load_round()
    confirmed = load_confirmation()
    players = load_all_players()
    submitted_players = [p for p in players if p["submitted"]]
    conn = connect()
    c = conn.cursor()
    st.subheader("ÁèæÂú®„ÅÆÁä∂Ê≥Å")
    st.markdown(f"**„ÇØ„É©„ÇπÂêçÔΩú{class_name}**")
    st.markdown(f"**„É©„Ç¶„É≥„Éâ {round_num}ÔΩú„Ç∞„É´„Éº„Éó‰æ°ÂÄ§:** {group_value} ÂÜÜ")
    st.markdown(f"**ÂèÇÂä†‰∫∫Êï∞:** {len(players)} ‰∫∫")
    st.markdown(f"**ÊèêÂá∫Ê∏à„Åø‰∫∫Êï∞:** {len(submitted_players)} ‰∫∫")
    st.subheader("üìä „Éó„É¨„Ç§„É§„Éº„Éá„Éº„Çø")
    df = pd.read_sql_query("SELECT * FROM players", conn)
    st.dataframe(df)
    # ÈÄÜÈúÄË¶Å„Éª‰æõÁµ¶Èñ¢Êï∞„Ç∞„É©„ÉïÊèèÁîª
    players = load_all_players()
    price_range = list(range(0, 201))
    prices, demand, supply = compute_inverse_demand_supply(players)

    fig, ax = plt.subplots()
    ax.plot(demand, prices, label="D")
    ax.plot(supply, prices, label="S")
    ax.set_xlabel("Q")
    ax.set_ylabel("P")
    ax.set_title("Market Demmand and Supply")
    ax.legend()
    st.pyplot(fig)

    st.subheader("üìà Â∏ÇÂ†¥Á≤æÁÆóÂá¶ÁêÜ")
    if st.button("‰æ°Ê†º„ÇíÈõÜË®à„Åó„Å¶Ë°®Á§∫"):
        price = set_payoffs(submitted_players, group_value, class_name, round_num)
        st.success(f"Â∏ÇÂ†¥‰æ°Ê†º„ÅØ {price} ÂÜÜ„Å´Ë®≠ÂÆö„Åï„Çå„Åæ„Åó„Åü„ÄÇ")

   
    if not confirmed:
        if st.button("Â†±ÈÖ¨„ÇíÁ¢∫ÂÆö„Åô„Çã"):
            confirm_results()
            st.success("ÁµêÊûú„ÇíÁ¢∫ÂÆö„Åó„Åæ„Åó„Åü„ÄÇ„Éó„É¨„Ç§„É§„Éº„Å´Â†±ÈÖ¨„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ")

    if confirmed:
        st.subheader("ÁµêÊûú‰∏ÄË¶ßÔºàÂ†±ÈÖ¨Á¢∫ÂÆöÊ∏àÔºâ")
        players = load_all_players()
        df_result = pd.DataFrame(players)
        st.dataframe(df_result[["name", "choice", "bid", "qty", "money", "endowment", "payoff"]], use_container_width=True)

    st.subheader("üì¶ Â±•Ê≠¥„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ")
    conn = connect()
    history_df = pd.read_sql_query("SELECT * FROM player_history WHERE class_name = ?", conn, params=(class_name,))
    conn.close()
    history_csv = history_df.to_csv(index=False).encode("utf-8")
    st.download_button("Â±•Ê≠¥CSV„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ", data=history_csv, file_name=f"history_{class_name}.csv", mime="text/csv")


    # „É©„Ç¶„É≥„ÉâÂà∂Âæ°
    st.sidebar.header("ÂÆüÈ®ìÂà∂Âæ°")
    if st.sidebar.button("Ê¨°„ÅÆ„É©„Ç¶„É≥„Éâ„Å∏"):
        next_round()
        st.sidebar.success("„É©„Ç¶„É≥„Éâ„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü")

    if st.sidebar.button("ÂÆüÈ®ì„É™„Çª„ÉÉ„Éà"):
        reset_experiment()
        st.sidebar.success("ÂÖ®„Å¶„ÅÆ„Éó„É¨„Ç§„É§„Éº„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü")
        time.sleep(2)
        st.rerun()
    st.sidebar.header("Êõ¥Êñ∞")
    if st.sidebar.button("Êõ¥Êñ∞"):
        st.rerun()


# --- „É°„Ç§„É≥Âá¶ÁêÜ ---
def main():
    query_params = st.query_params
    class_name = query_params.get("class", "Unknown")
    mode = query_params.get("mode", "player")
    initialize_db()

    if class_name == "Unknown":
        st.error("„ÇØ„É©„ÇπÊÉÖÂ†±„ÅåURL„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰æã: ?class=A")
        return

    with st.sidebar:
        st.title("‚öôÔ∏è „É¢„Éº„ÉâÂàáÊõø")
        admin_mode = st.checkbox("ÁÆ°ÁêÜËÄÖ„É¢„Éº„Éâ")

    if admin_mode:
        password = st.sidebar.text_input("„Éë„Çπ„ÉØ„Éº„Éâ", type="password")
        if password == st.secrets["admin_pw"]:
            show_admin_ui(class_name)
        else:
            st.error("„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÈÅï„ÅÑ„Åæ„Åô")
            st.stop()
    else:
        show_player_ui(class_name)

if __name__ == "__main__":
    main()
